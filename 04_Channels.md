# 고루틴에서 계산한 값을 메인 루틴에서 얻는 방법?

```go
func main() {
    go func(a, b int) {
        c := a + b
    }(1,2)
    // 고루틴에서 계산한 c 값을 메모리 공유 없이 얻고 싶다. 어떻게 할 수 있을까?
}
```

# 채널(Channels)

- 고루틴 간 데이터 통신에는 채널이 사용된다.
- 채널은 고루틴 실행을 동기화하는데 도움이 된다.
- 하나의 고루틴은 다른 고루틴이 어떤 계산 단계에 있는지 알려주고 실행을 동기화할 수 있다.
- 채널은 특정 유형의 값을 송수신하는 데 사용된다.
- 채널은 스레드세이프하다. 여러 고루틴에서 동시에 값을 주고 받을 수 있는 채널 변수를 사용할 수 있다.

# 선언 및 초기화

```go
var ch chan T   // 채널 선언
ch = make(chan T)   // make 함수로 메모리 할당 -> make 함수는 할당된 메모리의 참조를 반환한다
```

또는

```go
ch := make(chan T) // 메모리 선언 및 할당
```

# `<-` 연산자

- 포인터 연산자를 사용하여 채널에서 값을 주고 받을 수 있으며 화살표 방향은 데이터 흐름의 방향을 나타낸다.

## 송신(Send)

송신의 경우 화살표 방향은 채널에 값을 쓰고 있음을 나타낸다.

```go
ch <- v
```

## 수신(Receive)

수신의 경우 화살표 방향은 채널로부터 값을 받아서 변수에 복사함을 나타낸다.

```go
v = <-ch
```

# 채널은 블락된다(Channels are blocking)

고루틴은 수신기가 준비되기를 기다린다.

```go
ch <- value
```

고루틴은 값이 전송되기를 기다린다.

```go
<- ch
```

채널은 값을 전송하거나 받을 준비가 되면 고루틴을 다시 실행할 수 있도록 만드는 책임이 있다.

# 채널 닫기

채널을 닫는 것은 송신 고루틴이 수신 고루틴에게 송신자는 채널에 보낼 값이 더 이상 없고 수신자가 블로킹을 해제하고 다른 계산을 진행할 수 있도록 한다.

```go
close(ch)
```

# 채널 값 수신

```go
value, ok = <- ch
// value: 채널로부터 수신한 값
// ok: 불리언 값. 채널에서 읽어오는 값이 쓰기에 의해 생성된 값인 경우 true, 채널 닫기에 의해 생성되는 기본 값인 경우 false.
```